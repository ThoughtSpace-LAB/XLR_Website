---
import linearsvg from '~/assets/icons/serena/Linearsvg.svg?url';
---

<svg id="linear-track-svg" width="80vw" height="120vh" viewBox="0 0 1152 1488" preserveAspectRatio="xMinYMin meet" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="ll-grad" x1="0" x2="0" y1="0" y2="1">
      <stop offset="0" stop-color="#00E6D0" />
      <stop offset="1" stop-color="#3DF9DF" />
    </linearGradient>
  </defs>

  <path id="track"
    d="M15.8 15.1128C35.809 75.8628 -7.73331 274.441 191.8 417.113C384.8 555.113 1135.8 555.6 1135.8 791.084C1135.8 1026.57 15.8 902.564 15.8 1152.45C15.8 1402.34 596.559 1353.91 596.559 1473.11"
    fill="none"
    stroke="url(#ll-grad)"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    opacity="0.6"
  />

  <g id="linearsvg" transform="translate(0,0)">
    <image id="linearsvg-image" href={linearsvg} x="-12" y="-12" width="24" height="24" preserveAspectRatio="xMidYMid meet" />
  </g>
</svg>

<style>
  :root { --linear-icon-size: 24px; }
  #linear-track-svg { display: block; }
</style>

<script>
  if (typeof window !== 'undefined') {
    (function () {
      const svg = document.getElementById('linear-track-svg');
      const path = document.getElementById('track');
      const mover = document.getElementById('linearsvg');

      if (!svg || !path || !mover) return;

      const duration = 6000; // ms per loop
      const loop = true;

      const pathEl = path as unknown as SVGPathElement;
      const total = pathEl.getTotalLength();
      // how far down (in SVG user units) the mover should descend over one full traversal
      const downDistance = 300; // adjust as needed

      let start: number | null = null;
      // accumulated scroll offset (in CSS px, roughly equal to SVG user units since viewBox matches)
      let accumulatedScroll = 0;
      // track last seen scrollY to compute per-frame delta
      let lastScrollY = window.scrollY || 0;

      function step(ts: number) {
        if (start === null) start = ts;
        const elapsed = ts - start;
        const t = ((elapsed % duration) / duration);
        const len = t * total;

        // measure scroll delta since last frame so mover follows page scroll speed
        const currentScrollY = window.scrollY || 0;
        const scrollDelta = currentScrollY - lastScrollY;
        lastScrollY = currentScrollY;

        // accumulate scroll deltas; optional decay can be applied if desired
        accumulatedScroll += scrollDelta;

        const pt = pathEl.getPointAtLength(len);
        const delta = Math.min(2, total - len);
        const ptF = pathEl.getPointAtLength(Math.min(len + delta, total));
        const angle = Math.atan2(ptF.y - pt.y, ptF.x - pt.x) * 180 / Math.PI;

        // add the path-based downward offset plus the user's scroll movement
        const downY = pt.y + t * downDistance + accumulatedScroll;
        const trans = 'translate(' + pt.x + ', ' + downY + ') rotate(' + angle + ')';
        mover.setAttribute('transform', trans);

        if (loop || elapsed < duration) requestAnimationFrame(step);
      }

      requestAnimationFrame((ts) => { start = ts; requestAnimationFrame(step); });
    })();
  }
</script>

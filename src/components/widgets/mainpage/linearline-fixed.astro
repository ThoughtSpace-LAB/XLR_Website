---

---

<style>
  :root{
    --line-length: 80vh;
    --line-color: rgba(255,255,255,0.9);
    --dot-outer-size: 5px;
    --dot-inner-size: 5px;
  }

  .line-container{
    width: 100%;
    height: 1px;
    pointer-events: none;
  }

  .vertical-line{
    left: 50%;
    top: 0;
    transform: translateX(-50%);
    width: 2px;
    height: var(--line-length);
    background: linear-gradient(to bottom, rgba(255,255,255,0.0) 0%, var(--line-color) 20%, var(--line-color) 100%);
    opacity: 0.9;
    border-radius: 2px;
  }

  #mover-overlay{
    position: absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:90;
    /* 新增：设置背景色，初始为透明 */
    background-color: transparent;
    transition: background-color 700ms ease; /* 动画过渡 */
  }

  #mover-dot{
    position: absolute;
    width: var(--dot-outer-size);
    height: var(--dot-outer-size);
    border-radius: 9999px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    background: white;
    mix-blend-mode: soft-light;
    box-shadow:
      0 0 5px 5px rgba(255,255,255,0.3),
      0 0 10px 10px rgba(154, 255, 255, 0.2),
      0 0 20px 20px rgba(218, 248, 255, 0.2);
    transform: translate(-50%, -50%);
    transition: left 0.05s linear, top 0.05s linear; /* 保持移动的过渡 */
    /* 新增：为爆炸过渡添加一个更长的持续时间，使其平滑膨胀 */
    transition-property: left, top, width, height, border-radius, background, box-shadow;
    transition-duration: 0.05s, 0.05s, 700ms, 700ms, 700ms, 700ms, 700ms;
    transition-timing-function: linear, linear, ease-in-out, ease-in-out, ease-in-out, ease-in-out, ease-in-out;
    will-change: left, top, width, height, transform;
  }


  #mover-dot.explode{
    left: 50vw !important; /* 让它在屏幕中央开始膨胀 */
    top: 50vh !important;
    width: 200vw !important; /* 膨胀到超大尺寸 */
    height: 200vh !important;
    border-radius: 0 !important;
    box-shadow: none !important;
    background: white !important;
    mix-blend-mode: normal !important; /* 确保它不再是 soft-light */
  }

  #mover-dot.explode .inner{ display: none; }

  /* 新增类：用于控制整个页面的变白效果 */
  .page-white-out #mover-overlay {
    background-color: white !important; /* 让覆盖层变白 */
    pointer-events: all; /* 可选：如果变白后希望禁止用户交互 */
  }
</style>




<div class="relative w-full h-full">
    <div class="line-container" id="line-section"  class="absolute w-full h-full" aria-hidden="true">
  <div class="vertical-line" id="vertical-line"></div>
</div>
<div id="mover-overlay" class="absolute w-full h-full" aria-hidden="true">
  <div id="mover-dot"><div class="inner"></div></div>
</div>
</div>

<script>
  if (typeof window !== 'undefined') {
    (function () {
      const container = document.getElementById('line-section');
      const vline = document.getElementById('vertical-line');
      const mover = document.getElementById('mover-dot');
      if (!container || !vline || !mover) return;

      let pathHeight = vline.clientHeight || (window.innerHeight * 0.8);
      let started = false;
      let exploded = false;
      let startScroll = 0;

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      function onScroll() {
        if (!started || exploded) return;
        const current = window.scrollY || window.pageYOffset;
        const progress = clamp((current - startScroll) / pathHeight, 0, 1);

        const rect = vline.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + progress * rect.height;

        mover.style.left = x + 'px';
        mover.style.top = y + 'px';

        if (progress >= 1 && !exploded) {
          exploded = true;
          setTimeout(() => { 
            mover.classList.add('explode'); 
            mover.parentElement.classList.add('page-white-out'); // 添加变白效果
          }, 80);
        }
      }

      const io = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !started) {
            started = true;
            const rect = vline.getBoundingClientRect();
            startScroll = window.scrollY + rect.top;
            pathHeight = rect.height || (window.innerHeight * 0.8);
            window.addEventListener('scroll', onScroll, { passive: true });
            requestAnimationFrame(onScroll);
          }
        });
      }, { threshold: 0.1 });

      io.observe(container);

      window.addEventListener('beforeunload', () => {
        window.removeEventListener('scroll', onScroll);
        io.disconnect();
      });

    })();
  }
</script>
